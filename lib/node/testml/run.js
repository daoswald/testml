// Generated by CoffeeScript 2.3.1
(function() {
  var TestMLFunction, lodash;

  require('../testml');

  if (TestML.env['TESTML_DEVEL']) {
    require('ingy-prelude');
  }

  lodash = require('lodash');

  module.exports = TestML.Run = (function() {
    class Run {
      //----------------------------------------------------------------------------
      constructor(params = {}) {
        var testml;
        ({file: this.file, bridge: this.bridge, stdlib: this.stdlib, testml = {}} = params);
        ({testml, code: this.code, data: this.data} = testml);
        this.version = testml;
        if (!TestML.browser) {
          global._ = lodash;
        }
        return;
      }

      from_file(file) {
        var fs, testml;
        this.file = file;
        fs = require('fs');
        ({testml, code: this.code, data: this.data} = JSON.parse(this.file === '-' ? fs.readFileSync('/dev/stdin').toString() : fs.readFileSync(this.file).toString()));
        this.version = testml;
        return this;
      }

      test() {
        var j, len, ref, statement;
        this.testml_begin();
        ref = this.code;
        for (j = 0, len = ref.length; j < len; j++) {
          statement = ref[j];
          this.exec_expr(statement);
        }
        this.testml_end();
      }

      //----------------------------------------------------------------------------
      getp(name) {
        var value;
        if (!this.block) {
          return;
        }
        value = this.block.point[name];
        if (value != null) {
          value = this.exec(value);
        }
        return value;
      }

      getv(name) {
        return this.vars[name];
      }

      setv(name, value) {
        this.vars[name] = value;
      }

      //----------------------------------------------------------------------------
      exec(expr) {
        return this.exec_expr(expr)[0];
      }

      exec_expr(expr, context = []) {
        var args, call, name, opcode, return_, value;
        if (this.type(expr) !== 'expr') {
          return [expr];
        }
        args = _.clone(expr);
        opcode = name = args.shift();
        if (call = this.constructor.vtable[opcode]) {
          if (_.isArray(call)) {
            call = call[0];
          }
          // Might need to pass context to => calls here.
          return_ = this[call](...args);
        } else {
          args.unshift(...(_.reverse(context)));
          if ((value = this.vars[name]) != null) {
            if (args.length) {
              if (!this.type(value === 'func')) {
                die(`Variable '${name}' has args but is not a function`);
              }
              return_ = this.exec_func(value, args);
            } else {
              return_ = value;
            }
          } else if (name.match(/^[a-z]/)) {
            return_ = this.call_bridge(name, args);
          } else if (name.match(/^[A-Z]/)) {
            return_ = this.call_stdlib(name, args);
          } else {
            throw `Can't resolve TestML function '${name}'`;
          }
        }
        if (return_ === void 0) {
          return [];
        } else {
          return [return_];
        }
      }

      exec_dot(...calls) {
        var call, context, e, j, len;
        context = [];
        this.error = null;
        for (j = 0, len = calls.length; j < len; j++) {
          call = calls[j];
          if (!this.error) {
            try {
              if (this.type(call) === 'func') {
                this.exec_func(call, context[0]);
                context = [];
              } else {
                context = this.exec_expr(call, context);
              }
              if (this.thrown) {
                this.error = this.cook(this.thrown);
                this.thrown = null;
              }
            } catch (error) {
              e = error;
              this.error = this.call_stdlib('Error', [`${e}`]);
            }
          } else {
            if (call[0] === 'Catch') {
              context = [this.error];
              this.error = null;
            }
          }
        }
        if (this.error) {
          throw 'Uncaught Error: ' + this.error[1].msg;
        }
        if (!context.length) {
          return;
        }
        return context[0];
      }

      for_each(list, expr) {
        var item, j, len, ref, results;
        list = this.exec(list);
        expr = this.exec(expr);
        ref = list[0];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          item = ref[j];
          this.vars._ = [item];
          if (this.type(expr) === 'func') {
            if (expr[1].length === 0) {
              results.push(this.exec_func(expr));
            } else {
              results.push(this.exec_func(expr, [item]));
            }
          } else {
            results.push(this.exec_expr(expr));
          }
        }
        return results;
      }

      pick_loop(list, expr) {
        var block, j, len, ref;
        ref = this.data;
        for (j = 0, len = ref.length; j < len; j++) {
          block = ref[j];
          this.block = block;
          if (block.point.ONLY && !this.warned_only) {
            this.err("Warning: TestML 'ONLY' in use.");
            this.warned_only = true;
          }
          this.exec_expr(['()', list, expr]);
        }
        this.block = void 0;
      }

      pick_exec(list, expr) {
        var j, len, pick, point;
        pick = true;
        for (j = 0, len = list.length; j < len; j++) {
          point = list[j];
          if ((point.match(/^\*/) && (this.block.point[point.slice(1)] == null)) || (point.match(/^\!\*/) && (this.block.point[point.slice(2)] != null))) {
            pick = false;
            break;
          }
        }
        if (pick) {
          if (this.type(expr) === 'func') {
            return this.exec_func(expr);
          } else {
            return this.exec_expr(expr);
          }
        }
      }

      exec_func([op, signature, statements], args = []) {
        var i, j, len, statement, v;
        if (signature.length > 1 && args.length === 1 && this.type(args) === 'list') {
          args = args[0];
        }
        if (signature.length !== args.length) {
          throw `TestML function expected '${signature.length}' arguments, but was called with '${args.length}' arguments`;
        }
        for (i in signature) {
          v = signature[i];
          this.vars[v] = args[i];
        }
        for (j = 0, len = statements.length; j < len; j++) {
          statement = statements[j];
          this.exec_expr(statement);
        }
      }

      call_func(func) {
        var name;
        name = func[0];
        func = this.exec(func);
        if (!((func != null) && this.type(func) === 'func')) {
          throw `Tried to call '${name}' but is not a function`;
        }
        return this.exec_func(func);
      }

      get_str(string) {
        return this.interpolate(string);
      }

      get_hash(hash, key) {
        var type;
        hash = this.exec(hash);
        key = this.exec(key);
        type = this.type(hash);
        return this.cook((function() {
          switch (false) {
            case type !== 'hash':
              return hash[0][key];
            case type !== 'error':
              return hash[1][key];
            default:
              return `Can't lookup hash key on value of type '${type}'`;
          }
        })());
      }

      get_list(list, index) {
        list = this.exec(list);
        return this.cook(list[0][index]);
      }

      get_point(name) {
        return this.getp(name);
      }

      set_var(name, expr) {
        if (this.type(expr) === 'func') {
          this.setv(name, expr);
        } else {
          this.setv(name, this.exec(expr));
        }
      }

      or_set_var(name, expr) {
        if (this.vars[name] != null) {
          return;
        }
        if (this.type(expr) === 'func') {
          this.setv(name, expr);
        } else {
          this.setv(name, this.exec(expr));
        }
      }

      assert_eq(left, right, label) {
        var got, method, want;
        this.vars.Got = got = this.exec(left);
        this.vars.Want = want = this.exec(right);
        method = this.get_method('==', got, want);
        this[method](got, want, label);
      }

      assert_str_eq_str(got, want, label) {
        return this.testml_eq(got, want, this.get_label(label));
      }

      assert_num_eq_num(got, want, label) {
        return this.testml_eq(got, want, this.get_label(label));
      }

      assert_bool_eq_bool(got, want, label) {
        return this.testml_eq(got, want, this.get_label(label));
      }

      assert_has(left, right, label) {
        var got, method, want;
        got = this.exec(left);
        want = this.exec(right);
        method = this.get_method('~~', got, want);
        this[method](got, want, label);
      }

      assert_str_has_str(got, want, label) {
        this.vars.Got = got;
        this.vars.Want = want;
        return this.testml_has(got, want, this.get_label(label));
      }

      assert_str_has_list(got, want, label) {
        var j, len, ref, results, str;
        ref = want[0];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          str = ref[j];
          results.push(this.assert_str_has_str(got, str, label));
        }
        return results;
      }

      assert_list_has_str(got, want, label) {
        this.vars.Got = got;
        this.vars.Want = want;
        return this.testml_list_has(got[0], want, this.get_label(label));
      }

      assert_list_has_list(got, want, label) {
        var j, len, ref, results, str;
        ref = want[0];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          str = ref[j];
          results.push(this.assert_list_has_str(got, str, label));
        }
        return results;
      }

      assert_like(left, right, label) {
        var got, method, want;
        got = this.exec(left);
        want = this.exec(right);
        method = this.get_method('=~', got, want);
        this[method](got, want, label);
      }

      assert_str_like_regex(got, want, label) {
        this.vars.Got = got;
        this.vars.Want = `/${want[1]}/`;
        want = this.uncook(want);
        return this.testml_like(got, want, this.get_label(label));
      }

      assert_str_like_list(got, want, label) {
        var j, len, ref, regex, results;
        ref = want[0];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          regex = ref[j];
          results.push(this.assert_str_like_regex(got, regex, label));
        }
        return results;
      }

      assert_list_like_regex(got, want, label) {
        var j, len, ref, results, str;
        ref = got[0];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          str = ref[j];
          results.push(this.assert_str_like_regex(str, want, label));
        }
        return results;
      }

      assert_list_like_list(got, want, label) {
        var j, len, ref, regex, results, str;
        ref = got[0];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          str = ref[j];
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = want[0];
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              regex = ref1[k];
              results1.push(this.assert_str_like_regex(str, regex, label));
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      //----------------------------------------------------------------------------
      type(value) {
        var name, type, types;
        if (typeof value === 'undefined') {
          throw "Can't get type of undefined value";
        }
        if (value === null) {
          return 'null';
        }
        types = this.constructor.types;
        type = types[typeof value] || types[name = value.constructor.name] || (function() {
          if (name === 'Array') {
            if (value.length === 0) {
              return 'none';
            } else {
              if (typeof value[0] === 'string') {
                return types.testml[value[0]] || 'expr';
              } else {
                return types.group[value[0].constructor.name] || 'native';
              }
            }
          } else {
            throw `Bad TestML internal value: '${name}'`;
          }
        })();
        return type || (function() {
          throw `Can't get type of ${require('util').inspect(value)}`;
        })();
      }

      cook(value) {
        var name;
        if (value === void 0) {
          return [];
        }
        if (value === null) {
          return null;
        }
        name = value.constructor.name;
        if (name.match(/^(?:String|Number|Boolean)$/)) {
          return value;
        }
        if (name.match(/^(?:Array|Object)$/)) {
          return [value];
        }
        if (name === 'RegExp') {
          return ['/', value];
        }
        if (name === 'TestMLError') {
          return ['!', value];
        }
        if (name === 'TestMLFunction') {
          return value['func'];
        }
        return ['?', value];
      }

      uncook(value) {
        var type;
        type = this.type(value);
        switch (false) {
          case !type.match(/^(?:str|num|bool|null)$/):
            return value;
          case !type.match(/^(?:list|hash)$/):
            return value[0];
          case !type.match(/^(?:error|native)$/):
            return value[1];
          case type !== 'func':
            return new TestMLFunction(value);
          case type !== 'regex':
            if (typeof value[1] === 'string') {
              return new RegExp(value[1]);
            } else {
              return value[1];
            }
            break;
          case type !== 'none':
            return void 0;
          default:
            throw `Can't uncook '${require('util').inspect(value)}'`;
        }
      }

      call_stdlib(name, args) {
        var call;
        this.stdlib || (this.stdlib = new (require('../testml/stdlib'))(this));
        call = _.lowerCase(name).replace(/\s+/g, '');
        if (!this.stdlib[call]) {
          throw `Unknown TestML Standard Library function: '${name}'`;
        }
        args = _.map(args, (x) => {
          return this.uncook(this.exec(x));
        });
        return this.cook(this.stdlib[call](...args));
      }

      call_bridge(name, args) {
        var call, return_;
        this.bridge || (this.bridge = new (require(process.env.TESTML_BRIDGE)));
        call = name.replace(/-/g, '_');
        if (!this.bridge[call]) {
          throw `Can't find bridge function: '${name}'`;
        }
        args = _.map(args, (x) => {
          return this.uncook(this.exec(x));
        });
        return_ = this.bridge[call](...args);
        if (return_ == null) {
          return;
        }
        return this.cook(return_);
      }

      get_method(key, ...args) {
        var arg, entry, j, len, method, name, pattern, sig, sig_str, vtable;
        sig = [];
        for (j = 0, len = args.length; j < len; j++) {
          arg = args[j];
          sig.push(this.type(arg));
        }
        sig_str = sig.join(',');
        entry = this.constructor.vtable[key];
        [name, pattern, vtable] = entry;
        method = vtable[sig_str] || pattern.replace(/%(\d+)/g, function(m, num) {
          return sig[num - 1];
        });
        if (!method) {
          throw `Can't resolve ${name}(${sig_str})`;
        }
        if (!this[method]) {
          throw `Method '${method}' does not exist`;
        }
        return method;
      }

      get_label(label_expr = '') {
        var block_label, label;
        label = this.exec(label_expr);
        label || (label = this.getv('Label') || '');
        block_label = this.block != null ? this.block.label : '';
        if (label) {
          label = label.replace(/^\+/, block_label);
          label = label.replace(/\+$/, block_label);
          label = label.replace(/\{\+\}/, block_label);
        } else {
          label = block_label;
        }
        return this.interpolate(label, true);
      }

      interpolate(string, label = false) {
        var transform, transform1, transform2;
        transform = (value) => {
          if (label) {
            switch (false) {
              case !this.type(value).match(/^(?:list|hash)$/):
                return JSON.stringify(value[0]).replace(/"/g, '');
              default:
                return String(value).replace(/\n/g, '␤');
            }
          } else {
            switch (false) {
              case !this.type(value).match(/^(?:list|hash)$/):
                return JSON.stringify(value[0]).replace(/"/g, '');
              default:
                return String(value);
            }
          }
        };
        transform1 = (m, name) => {
          var value;
          if ((value = this.vars[name]) == null) {
            return '';
          }
          return transform(value);
        };
        transform2 = (m, name) => {
          var ref, value;
          if ((value = (ref = this.block) != null ? ref.point[name] : void 0) == null) {
            return '';
          }
          return transform(value);
        };
        string = string.replace(/\{([\-\w]+)\}/g, transform1);
        string = string.replace(/\{\*([\-\w]+)\}/g, transform2);
        return string;
      }

      //----------------------------------------------------------------------------
      test_types() {
        var Bad, e;
        Bad = class Bad {};
        console.log(`null   - ${this.type(null)}`);
        console.log(`none   - ${this.type([])}`);
        console.log(`str    - ${this.type("")}`);
        console.log(`num    - ${this.type(1)}`);
        console.log(`bool   - ${this.type(false)}`);
        console.log(`list   - ${this.type([[]])}`);
        console.log(`hash   - ${this.type([{}])}`);
        console.log(`regex  - ${this.type(['/', ''])}`);
        console.log(`func   - ${this.type(['=>', ''])}`);
        console.log(`error  - ${this.type(['!', ''])}`);
        console.log(`native - ${this.type(['?', ''])}`);
        console.log(`expr   - ${this.type(['foo'])}`);
        console.log(`new Bad   - ${((function() {
          try {
            return this.type(new Bad);
          } catch (error) {
            e = error;
            return e;
          }
        }).call(this))}`);
        console.log(`new Regex - ${((function() {
          try {
            return this.type(/x/);
          } catch (error) {
            e = error;
            return e;
          }
        }).call(this))}`);
        console.log(`undefined - ${((function() {
          try {
            return this.type();
          } catch (error) {
            e = error;
            return e;
          }
        }).call(this))}`);
        throw "Tested TestML internal types";
      }

    };

    Run.vtable = {
      '==': [
        'assert_eq',
        'assert_%1_eq_%2',
        {
          'str,str': '',
          'num,num': '',
          'bool,bool': ''
        }
      ],
      '~~': [
        'assert_has',
        'assert_%1_has_%2',
        {
          'str,str': '',
          'str,list': '',
          'list,str': '',
          'list,list': ''
        }
      ],
      '=~': [
        'assert_like',
        'assert_%1_like_%2',
        {
          'str,regex': '',
          'str,list': '',
          'list,regex': '',
          'list,list': ''
        }
      ],
      '.': 'exec_dot',
      '%': 'for_each',
      '%()': 'pick_loop',
      '()': 'pick_exec',
      '&': 'call_func',
      "$''": 'get_str',
      ':': 'get_hash',
      '[]': 'get_list',
      '*': 'get_point',
      '=': 'set_var',
      '||=': 'or_set_var'
    };

    Run.types = {
      string: 'str',
      number: 'num',
      boolean: 'bool',
      testml: {
        '=>': 'func',
        '/': 'regex',
        '!': 'error',
        '?': 'native'
      },
      group: {
        Object: 'hash',
        Array: 'list'
      }
    };

    Run.prototype.file = void 0;

    Run.prototype.version = void 0;

    Run.prototype.code = void 0;

    Run.prototype.data = void 0;

    Run.prototype.bridge = void 0;

    Run.prototype.stdlib = void 0;

    Run.prototype.vars = {};

    Run.prototype.block = void 0;

    Run.prototype.warned_only = false;

    Run.prototype.error = null;

    Run.prototype.throw = null;

    return Run;

  }).call(this);

  // (new TestML.Run).test_types()

  //------------------------------------------------------------------------------
  TestML.Block = class {
    constructor({
        label: label1,
        point: point1,
        user: user = ''
      }) {
      this.label = label1;
      this.point = point1;
      this.user = user;
    }

  };

  TestMLFunction = class {
    constructor(func1) {
      this.func = func1;
    }

  };

}).call(this);
